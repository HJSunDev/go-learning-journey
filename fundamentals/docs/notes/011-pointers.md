# 011. Go 指针 (Pointers)：直接操作内存的钥匙

[返回索引](../README.md) | [查看代码](../../011-pointers/main.go)

指针是 Go 语言中一个核心概念。掌握指针，才能真正理解 Go 的内存模型和参数传递机制。

**一句话定义**：指针是一个变量，它存储的是另一个变量的**内存地址**，而不是值本身。

## 1. 指针的两个核心操作符

Go 语言提供了两个操作符来使用指针：

| 操作符 | 名称     | 作用               |
| ------ | -------- | ------------------ |
| `&`  | 取地址符 | 获取变量的内存地址 |
| `*`  | 解引用符 | 获取指针指向的值   |

```go
x := 42
p := &x  // p 是指向 x 的指针，类型是 *int

fmt.Println(x)   // 42     - x 的值
fmt.Println(p)   // 0xc0000... - x 的内存地址
fmt.Println(*p)  // 42     - p 指向的值（也就是 x 的值）

*p = 100         // 通过指针修改 x 的值
fmt.Println(x)   // 100
```

**关键点**：`*p = 100` 修改的是 `p` 指向的那块内存，也就是变量 `x` 本身。这是指针的核心价值。

## 2. Go 是值传递语言

**这是理解指针的关键前提。**

在 Go 中，当你把变量传给函数时，函数收到的是这个变量的**副本**（拷贝），不是原始变量。

### 经典案例：失败的交换函数

假设你想写一个函数交换两个变量的值：

```go
func swapWrong(a, b int) {
    a, b = b, a // 交换的是副本
}

func main() {
    x, y := 1, 2
    swapWrong(x, y)
    fmt.Println(x, y) // 输出: 1 2 （没有变化！）
}
```

**执行流程图解**：

```
main 函数的栈:       swapWrong 函数的栈:
┌─────────────┐      ┌─────────────┐
│  x = 1      │      │  a = 1 (副本)│
│  y = 2      │ ---> │  b = 2 (副本)│
└─────────────┘      └─────────────┘
                           ↓
                     交换 a 和 b
                           ↓
                     ┌─────────────┐
                     │  a = 2      │
                     │  b = 1      │
                     └─────────────┘
                     函数返回后，这块内存被丢弃
                     x 和 y 完全没有被触及
```

问题在于：`a` 和 `b` 是 `x` 和 `y` 的**复制品**，函数内部的交换操作只影响这两个复制品，原始的 `x` 和 `y` 纹丝不动。

## 3. 指针传递：解决修改问题

要让函数能修改外部变量，需要传递变量的**地址**，而不是值：

```go
func swapRight(a, b *int) {
    *a, *b = *b, *a // 交换的是指针指向的值
}

func main() {
    x, y := 1, 2
    swapRight(&x, &y)   // 传递地址
    fmt.Println(x, y)   // 输出: 2 1 （成功交换！）
}
```

**执行流程图解**：

```
main 函数的栈:       swapRight 函数的栈:
┌─────────────┐      ┌─────────────┐
│  x = 1  ←───────────┤  a (指向x)  │
│  y = 2  ←───────────┤  b (指向y)  │
└─────────────┘      └─────────────┘
                           ↓
                     *a 和 *b 交换
                     （直接操作 x 和 y 的内存）
                           ↓
┌─────────────┐
│  x = 2      │  ← 原始变量被修改了！
│  y = 1      │
└─────────────┘
```

**核心区别**：

- 值传递：函数操作的是副本
- 指针传递：函数通过地址操作原始变量

## 4. 实战场景：修改结构体

在实际开发中，结构体（struct）是使用最频繁的类型。当函数需要修改结构体时，几乎总是使用指针。

### 错误示范：值传递

```go
type User struct {
    Name  string
    Level int
}

func upgradeWrong(u User) {
    u.Level++
}

func main() {
    user := User{Name: "Alice", Level: 1}
    upgradeWrong(user)
    fmt.Println(user.Level) // 输出: 1 （没变！）
}
```

`upgradeWrong` 收到的是 `user` 的完整拷贝，修改拷贝不影响原始数据。

### 正确做法：指针传递

```go
func upgradeRight(u *User) {
    u.Level++ // Go 语法糖：自动解引用，等同于 (*u).Level++
}

func main() {
    user := User{Name: "Alice", Level: 1}
    upgradeRight(&user)
    fmt.Println(user.Level) // 输出: 2 （成功！）
}
```

**Go 的语法糖**：当你通过指针访问结构体字段时，`u.Level` 会被编译器自动转换为 `(*u).Level`，无需手动解引用。

### 什么时候用指针传递结构体？

1. **需要修改结构体内容时** — 必须用指针
2. **结构体较大时** — 避免复制整个结构体的开销
3. **需要表示"可能为空"时** — `nil` 指针表示"没有值"

## 5. 引用类型的特殊性

Go 中有几种类型看起来不需要指针就能在函数内修改：

- `slice`（切片）
- `map`（映射）
- `channel`（通道）

```go
func doubleSlice(nums []int) {
    for i := range nums {
        nums[i] *= 2
    }
}

func main() {
    data := []int{1, 2, 3}
    doubleSlice(data)
    fmt.Println(data) // 输出: [2 4 6] （修改成功！）
}
```

**因为这些类型本身就是"引用类型"。**

以 slice 为例，它的内部结构大致是：

```go
type slice struct {
    ptr *array  // 指向底层数组的指针
    len int
    cap int
}
```

当你传递 `[]int` 给函数时，复制的是这个结构体（指针 + len + cap），但指针副本仍然指向同一个底层数组。所以修改元素是有效的。

**但注意**：如果函数内部对 slice 进行 `append` 导致扩容，或者重新赋值整个 slice，外部是看不到变化的。这时需要返回新 slice 或使用 `*[]int`。

## 6. nil 指针

指针的零值是 `nil`，表示"不指向任何东西"。

```go
var p *int
fmt.Println(p)        // <nil>
fmt.Println(p == nil) // true

// 危险！对 nil 指针解引用会导致 panic
// fmt.Println(*p)    // panic: runtime error: invalid memory address
```

**使用前必须检查**：

```go
if p != nil {
    fmt.Println(*p)
}
```

## 7. 何时使用指针？

| 场景                             | 是否使用指针 | 原因                     |
| -------------------------------- | ------------ | ------------------------ |
| 函数需要修改参数值               | 是           | 值传递无法修改原始变量   |
| 传递大结构体                     | 是           | 避免复制开销             |
| 需要表示"可能为空"               | 是           | `nil` 指针表示无值     |
| 传递 slice/map/channel           | 通常不需要   | 它们内部已经包含指针     |
| 传递小的不可变值（如 int, bool） | 否           | 复制开销很小，代码更清晰 |

## 8. 总结

1. **指针存储的是内存地址**，通过 `&` 获取地址，通过 `*` 访问指向的值
2. **Go 是值传递**：函数参数都是副本，想修改原始变量必须传指针
3. **结构体修改**：函数内修改结构体时，用指针传递
4. **引用类型**：slice/map/channel 本身包含指针，修改元素不需要额外指针
5. **nil 检查**：使用指针前必须检查是否为 nil
