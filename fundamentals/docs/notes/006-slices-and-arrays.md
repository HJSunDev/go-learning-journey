# 006. Go 切片与数组：动态与固定的选择

本章核心目标：**掌握切片的使用，理解数组的真实场景**。

---

## 1. 概述

Go 提供两种序列类型：**切片（Slice）** 和 **数组（Array）**。

| 特性                 | 切片 `[]T`  | 数组 `[n]T` |
| -------------------- | ------------- | ------------- |
| 长度                 | 动态可变      | 固定不变      |
| 类型                 | 引用类型      | 值类型        |
| 长度是否为类型一部分 | 否            | 是            |
| 赋值行为             | 共享底层数据  | 复制全部数据  |
| 使用频率             | **99%** | 1%            |

**一句话区别**：

```go
arr := [3]int{1, 2, 3}   // 数组：方括号里有数字
slc := []int{1, 2, 3}    // 切片：方括号里没数字
```

 Go 日常开发中几乎都使用切片，数组只在特定场景使用。

---

## 2. 切片（Slice）

### 2.1 创建切片

#### 方式一：字面量创建

```go
nums := []int{10, 20, 30, 40, 50}
names := []string{"Alice", "Bob", "Charlie"}
```

#### 方式二：make 创建

`make` 是创建切片的内置函数，可以指定长度和容量：

```go
// make([]T, length)
// 创建长度为 length 的切片，元素为零值
s1 := make([]int, 5)    // [0 0 0 0 0]

// make([]T, length, capacity)
// 创建长度为 length、容量为 capacity 的切片
s2 := make([]int, 0, 10)  // []，但预分配了 10 个元素的空间
```

**何时使用 make？**

- 需要预分配容量以避免频繁扩容
- 需要创建指定长度的零值切片

#### 方式三：从现有切片/数组派生

```go
original := []int{0, 1, 2, 3, 4, 5}
sub := original[1:4]   // [1 2 3]
```

---

### 2.2 切片的内部结构

切片本质是一个包含三个字段的结构体：

```
切片变量
┌──────────────────────┐
│ ptr  → 底层数组       │  指向第一个元素
│ len  = 3             │  当前元素数量
│ cap  = 5             │  底层数组容量
└──────────────────────┘
         ↓
底层数组: [10] [20] [30] [__] [__]
```

理解这个结构是理解切片行为的关键：

- **赋值时**：复制的是这三个字段，不是底层数据
- **子切片**：共享同一个底层数组

---

### 2.3 len() 和 cap()

```go
s := make([]int, 3, 5)
fmt.Println(len(s))  // 3 - 当前元素数量
fmt.Println(cap(s))  // 5 - 底层数组容量
```

| 函数       | 说明                                     |
| ---------- | ---------------------------------------- |
| `len(s)` | 切片的**长度**（可访问的元素数量） |
| `cap(s)` | 切片的**容量**（底层数组总大小）   |

---

### 2.4 切片操作符 `[start:end]`

切片操作符用于从现有切片/数组中提取子序列。

#### 基本语法

```go
nums := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

nums[2:5]   // [2 3 4]     - 索引 2 到 4（左闭右开）
nums[:3]    // [0 1 2]     - 从头到索引 2
nums[7:]    // [7 8 9]     - 从索引 7 到末尾
nums[:]     // [0 1 ... 9] - 完整切片
```

**规则**：

- 左闭右开：包含 start，不包含 end
- start 默认为 0，end 默认为 len
- Go **不支持**负数索引（Python 支持）

#### 完整切片表达式 `[start:end:max]`

第三个参数限制新切片的容量：

```go
s := []int{0, 1, 2, 3, 4, 5}
sub := s[1:3:4]

// len = 3 - 1 = 2
// cap = 4 - 1 = 3
```

**用途**：防止子切片意外修改原切片超出预期范围的元素。

---

### 2.5 append() 追加元素

`append` 是向切片追加元素的内置函数。

```go
s := []int{1, 2, 3}

// 追加一个元素
s = append(s, 4)        // [1 2 3 4]

// 追加多个元素
s = append(s, 5, 6, 7)  // [1 2 3 4 5 6 7]

// 追加另一个切片（使用 ... 展开）
extra := []int{8, 9}
s = append(s, extra...) // [1 2 3 4 5 6 7 8 9]
```

**关键点**：

- `append` **返回**新切片，必须接收返回值
- 如果容量不足，会分配新的底层数组

#### 扩容机制

当容量不足时，Go 会自动扩容：

```go
s := make([]int, 0)
for i := 1; i <= 10; i++ {
    s = append(s, i)
    fmt.Printf("len=%d, cap=%d\n", len(s), cap(s))
}
// 容量变化: 0 → 1 → 2 → 4 → 8 → 16
```

扩容规则：

如果每次 `append` 都要申请新内存并复制所有数据，性能会非常差（O(n^2)）。Go 采用**空间换时间**的策略：

1. **容量较小时**（如 < 256）：每次扩容**翻倍**（2倍），所以你看到了 1 → 2 → 4 → 8 → 16。
2. **容量较大时**：扩容系数逐渐平滑（不再翻倍，而是增长 1.25 倍左右），以避免浪费过多内存。

**最佳实践**：已知大小时预分配容量

```go
// 避免多次扩容
result := make([]int, 0, 1000)
for i := 0; i < 1000; i++ {
    result = append(result, i)
}
```

---

### 2.6 slices 标准库（Go 1.21+）

Go 1.21 引入了 `slices` 包，提供常用的切片操作函数。

```go
import "slices"
```

#### 比较切片：slices.Equal

切片**不能**用 `==` 直接比较，必须使用 `slices.Equal`：

```go
a := []int{1, 2, 3}
b := []int{1, 2, 3}
c := []int{1, 2, 4}

slices.Equal(a, b)  // true
slices.Equal(a, c)  // false

// a == b  // ❌ 编译错误！切片只能与 nil 比较
```

#### 排序：slices.Sort

```go
nums := []int{3, 1, 4, 1, 5, 9, 2, 6}
slices.Sort(nums)
// nums: [1 1 2 3 4 5 6 9]
```

#### 查找：slices.Contains / slices.Index

```go
nums := []int{10, 20, 30, 40}

slices.Contains(nums, 30)  // true
slices.Contains(nums, 99)  // false

slices.Index(nums, 30)     // 2（返回索引）
slices.Index(nums, 99)     // -1（未找到）
```

#### 其他常用函数

| 函数                          | 说明                     |
| ----------------------------- | ------------------------ |
| `slices.Clone(s)`           | 深拷贝切片（独立副本）   |
| `slices.Reverse(s)`         | 原地反转                 |
| `slices.Max(s)`             | 返回最大值               |
| `slices.Min(s)`             | 返回最小值               |
| `slices.Delete(s, i, j)`    | 删除索引 i 到 j-1 的元素 |
| `slices.Insert(s, i, v...)` | 在索引 i 处插入元素      |

---

### 2.7 二维切片

Go 的二维切片本质是"切片的切片"。

#### 创建规则二维切片

```go
rows, cols := 3, 4

// 需要逐行分配
matrix := make([][]int, rows)
for i := range matrix {
    matrix[i] = make([]int, cols)
}

// 访问元素
matrix[1][2] = 42
```

#### 字面量创建

```go
grid := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}
```

#### 不规则二维切片（锯齿数组）

每行可以有不同的长度：

```go
jagged := [][]int{
    {1},
    {2, 3},
    {4, 5, 6},
    {7, 8, 9, 10},
}
```

这在其他语言（如 Java 的二维数组）中很难实现。

---

### 2.8 切片陷阱与最佳实践

#### 陷阱 1：子切片共享底层数组

```go
original := []int{1, 2, 3, 4, 5}
sub := original[1:4]  // [2 3 4]

sub[0] = 999

// original 也变了！[1 999 3 4 5]
```

**解决方案**：使用 `slices.Clone` 创建独立副本

```go
sub := slices.Clone(original[1:4])
```

#### 陷阱 2：nil 切片 vs 空切片

```go
var nilSlice []int          // nil
emptySlice := []int{}       // 非 nil，但长度为 0
makeEmpty := make([]int, 0) // 非 nil，但长度为 0
```

**好消息**：三者功能上几乎等价，都可以用 `append`、`len`、`cap`。

**建议**：优先使用 `var s []int`（nil 切片），更简洁。

#### 陷阱 3：append 可能返回新切片

```go
s := make([]int, 3, 3)  // 容量已满
s2 := append(s, 4)      // 触发扩容

s[0] = 999
// s2[0] 还是原值，因为 s2 指向新数组
```

**原则**：始终使用 `s = append(s, x)` 的形式。

---

## 3. 数组（Array）

### 3.1 声明与创建

```go
var arr1 [5]int                      // 零值初始化 [0 0 0 0 0]
arr2 := [5]int{1, 2, 3, 4, 5}        // 字面量
arr3 := [...]int{1, 2, 3}            // 编译器推断长度（3）
arr4 := [5]int{0: 10, 2: 30, 4: 50}  // 指定索引 [10 0 30 0 50]
```

### 3.2 数组的核心特征

#### 特征 1：长度是类型的一部分

`[3]int` 和 `[5]int` 是**完全不同的类型**：

```go
var a [3]int
var b [5]int
// a = b  // ❌ 编译错误：类型不匹配
```

这意味着函数参数不灵活：

```go
func sum(arr [3]int) int { ... }

sum([3]int{1, 2, 3})     // ✅
sum([5]int{1, 2, 3, 4, 5}) // ❌ 类型不匹配
```

#### 特征 2：数组是值类型

赋值时复制**整个数组**：

```go
a := [3]int{1, 2, 3}
b := a      // 复制
b[0] = 999
// a 仍是 [1 2 3]
```

#### 特征 3：数组可以用 == 比较

```go
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{1, 2, 4}

a == b  // true
a == c  // false
```

这是切片做不到的！

---

### 3.3 数组的真实使用场景

虽然切片更常用，但数组在以下场景有不可替代的优势：

#### 场景 1：RGB 颜色值

颜色总是恰好 3 个分量（红、绿、蓝）：

```go
type RGB [3]uint8

red := RGB{255, 0, 0}
green := RGB{0, 255, 0}
```

#### 场景 2：坐标点

2D/3D 坐标的维度是固定的：

```go
type Point2D [2]float64
type Point3D [3]float64

origin := Point2D{0, 0}
vertex := Point3D{1.0, 2.0, 3.0}
```

#### 场景 3：密码学哈希值

SHA-256 哈希总是 32 字节：

```go
type SHA256Hash [32]byte

// crypto/sha256 包返回这种类型
hash := sha256.Sum256([]byte("hello"))
```

#### 场景 4：固定大小缓冲区

在栈上分配，避免堆分配开销：

```go
var buffer [4096]byte
n, _ := file.Read(buffer[:])
```

#### 场景 5：IPv4 地址

IP 地址固定 4 字节：

```go
type IPv4 [4]byte

localhost := IPv4{127, 0, 0, 1}
```

#### 场景 6：作为 map 的键

切片不能作为 map 键，但数组可以：

```go
cache := make(map[[2]int]string)
cache[[2]int{1, 2}] = "point(1,2)"
```

---

## 4. 对比总结

| 对比项           | 切片 `[]T`               | 数组 `[n]T`            |
| ---------------- | -------------------------- | ------------------------ |
| 长度             | 动态                       | 固定（编译时确定）       |
| 类型             | 引用类型                   | 值类型                   |
| 赋值             | 共享底层数组               | 复制全部数据             |
| 函数传参         | 高效（只传指针+长度+容量） | 低效（复制整个数组）     |
| 可用 `==` 比较 | ❌（只能与 nil 比较）      | ✅                       |
| 可作为 map 键    | ❌                         | ✅                       |
| 使用频率         | **99%**              | 1%                       |
| 适用场景         | 动态列表、函数参数         | 固定大小、值语义、map 键 |

**选择原则**：

1. **默认使用切片**
2. 只在以下情况使用数组：
   - 大小在编译时已知且永远不变
   - 需要值语义（赋值即独立副本）
   - 需要作为 map 的键
   - 性能敏感的小型固定缓冲区

---

## 5. 本章小结

| 概念       | 要点                                                    |
| ---------- | ------------------------------------------------------- |
| 切片创建   | 字面量 `[]int{1,2,3}` 或 `make([]int, len, cap)`    |
| len/cap    | `len` 是当前长度，`cap` 是底层容量                  |
| 切片操作符 | `s[start:end]` 左闭右开                               |
| append     | `s = append(s, x)` 必须接收返回值                     |
| slices 包  | `Equal`、`Sort`、`Contains`、`Clone` 等实用函数 |
| 二维切片   | 切片的切片，需逐行分配                                  |
| 数组特性   | 长度是类型一部分，值类型，可比较                        |
| 数组场景   | 颜色、坐标、哈希、缓冲区、IP 地址                       |

**核心记忆**：

1. 切片是**引用类型**，赋值共享数据
2. `append` 返回新切片，**必须接收返回值**
3. 用 `slices.Equal` 比较切片，用 `slices.Clone` 深拷贝
4. 数组只在"固定且永不变"的场景使用

---

## 6. 动手练习

1. 创建一个切片，使用切片操作符提取子切片，观察修改子切片是否影响原切片
2. 使用 `make` 预分配容量，对比有无预分配时 `append` 1000 个元素的容量变化
3. 使用 `slices.Sort` 对字符串切片排序
4. 创建一个 3x3 的二维切片，填充九宫格数字 1-9
5. 定义一个 `[4]byte` 类型的 IPv4 地址，用它作为 map 的键存储主机名
