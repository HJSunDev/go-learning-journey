# 004. Go 类型系统：值类型与引用类型

本章核心目标：**理解 Go 的类型系统，掌握"值类型"和"引用类型"的区别**。

---

## 1. 变量声明

在学习类型之前，先掌握如何声明变量。

### 1.1 三种声明方式

| 方式 | 语法 | 适用场景 |
| --- | --- | --- |
| `var` | `var x int = 1` | 包级别变量、需要零值、显式指定类型 |
| `:=` | `x := 1` | **函数内部（最常用）** |
| `const` | `const X = 1` | 常量（不可修改） |

```go
// var：标准声明
var name string = "Alice"
var count int              // 未赋值，自动为零值 0

// :=：短声明（只能在函数内）
age := 25                  // 编译器自动推断类型为 int

// const：常量
const Pi = 3.14159
```

### 1.2 `:=` 与 `=` 的区别

```go
count := 1    // := 声明新变量并赋值
count = 2     // =  给已有变量重新赋值

count := 3    // ❌ 错误：count 已存在，不能再用 := 声明
```

**记住**：`:=` 是"出生证"，`=` 是"改名"。

---

## 2. Go 的基本类型

### 2.1 类型一览

| 类别 | 类型 | 说明 |
| --- | --- | --- |
| 布尔 | `bool` | `true` / `false` |
| 整数 | `int`, `int8`, `int16`, `int32`, `int64` | 有符号 |
| 无符号整数 | `uint`, `uint8`, `uint16`, `uint32`, `uint64` | 无符号（≥0） |
| 浮点数 | `float32`, `float64` | 小数 |
| 字符串 | `string` | UTF-8 文本 |
| 字节 | `byte` | `uint8` 的别名 |
| 字符 | `rune` | `int32` 的别名，表示 Unicode 码点 |

### 2.2 整数类型命名规则

`int8` 中的数字表示**位数（bit）**，不是进制：

| 类型 | 位数 | 范围 | 使用场景 |
| --- | --- | --- | --- |
| `int8` | 8位 | -128 ~ 127 | 温度 |
| `uint8` | 8位 | 0 ~ 255 | RGB 颜色、年龄 |
| `int64` | 64位 | 很大 | 时间戳、数据库 ID |

**最佳实践**：日常用 `int` 即可，编译器自动选择合适大小。

---

## 3. 零值机制

Go 的特色：**变量声明后自动初始化为零值**，不存在"未定义"。

```go
var b bool       // false
var n int        // 0
var s string     // "" (空字符串)
var p *int       // nil
var sl []int     // nil
```

| 类型 | 零值 |
| --- | --- |
| 布尔 | `false` |
| 数值 | `0` |
| 字符串 | `""` |
| 指针、切片、映射、通道 | `nil` |

---

## 4. 核心概念：值类型 vs 引用类型

**这是本章最重要的内容。**

### 4.1 一句话理解

- **值类型**：赋值时**复制数据本身**，两个变量**互不影响**。
- **引用类型**：赋值时**复制"地址"**，两个变量**指向同一份数据**。

### 4.2 值类型示例

```go
a := 10
b := a      // 复制了值 10
b = 99
// a 还是 10，b 是 99
```

### 4.3 引用类型示例

```go
s1 := []int{1, 2, 3}
s2 := s1    // 复制了"地址"
s2[0] = 99
// s1 和 s2 都变成 [99, 2, 3]
```

### 4.4 类型分类表

| 值类型（独立副本） | 引用类型（共享数据） |
| --- | --- |
| 基本类型（`int`, `bool`, `string`...） | 切片 `[]T` |
| 数组 `[n]T` | 映射 `map[K]V` |
| 结构体 `struct` | 通道 `chan T` |
| | 指针 `*T` |

### 4.5 引用类型详解

#### 4.5.1 切片（Slice）`[]T`

**是什么**：切片是对数组的抽象，提供动态长度的列表。

**有什么用**：
- 动态数组：长度可以变化
- 高效传递：只复制切片头（指针+长度+容量），不复制底层数据
- 灵活操作：支持追加、截取等操作

**特征**：
- 引用语义：赋值时共享底层数组
- 三个属性：指针（指向底层数组）、长度（len）、容量（cap）
- 零值是 `nil`

**使用场景**：
- **99% 的业务场景**：列表、集合、数据查询结果
- 需要动态长度的数据集合

**如何使用**：

```go
// 创建
s1 := []int{1, 2, 3}              // 字面量
s2 := make([]int, 3)              // 长度为3，容量为3
s3 := make([]int, 0, 10)          // 长度为0，容量为10（预分配）

// 追加
s1 = append(s1, 4)                // [1, 2, 3, 4]

// 截取
s4 := s1[1:3]                     // [2, 3]（共享底层）

// 遍历
for i, v := range s1 {
    fmt.Printf("%d: %d\n", i, v)
}
```

**最佳实践**：
- 默认使用切片，而不是数组
- 已知容量时用 `make([]T, 0, cap)` 预分配，避免多次扩容
- 注意切片共享底层数组，修改会影响原切片

---

#### 4.5.2 映射（Map）`map[K]V`

**是什么**：键值对集合，类似其他语言的字典、哈希表。

**有什么用**：
- 快速查找：通过键 O(1) 时间复杂度查找值
- 去重：利用键的唯一性
- 分组：按某个属性分组数据

**特征**：
- 引用语义：赋值时共享底层数据
- 键必须可比较（基本类型、数组、结构体等，不能是切片、映射）
- 零值是 `nil`，不能直接写入

**使用场景**：
- 缓存、索引：`map[string]User`
- 计数器：`map[string]int`
- 分组统计：`map[string][]Order`

**如何使用**：

```go
// 创建
m1 := map[string]int{"Alice": 100, "Bob": 90}
m2 := make(map[string]int)

// 读写
m1["Alice"] = 95                 // 写入/更新
score := m1["Alice"]             // 读取
delete(m1, "Bob")                // 删除

// 检查键是否存在
score, ok := m1["Charlie"]        // ok=false 表示不存在

// 遍历
for k, v := range m1 {
    fmt.Printf("%s: %d\n", k, v)
}
```

**最佳实践**：
- 使用前检查键是否存在：`v, ok := m[key]`
- 并发访问需要加锁（或使用 `sync.Map`）
- 键类型选择可比较的类型

---

#### 4.5.3 通道（Channel）`chan T`

**是什么**：用于 goroutine 之间通信的管道。

**有什么用**：
- 并发通信：在 goroutine 间安全传递数据
- 同步：通过发送/接收实现同步
- 数据流：实现生产者-消费者模式

**特征**：
- 引用语义：赋值时共享同一个通道
- 类型安全：只能传递指定类型的数据
- 阻塞：发送和接收会阻塞，直到对方准备好

**使用场景**：
- 并发编程：goroutine 间传递数据
- 任务队列：生产者-消费者模式
- 信号传递：通知、取消等

**如何使用**：

```go
// 创建
ch1 := make(chan int)             // 无缓冲通道
ch2 := make(chan int, 10)         // 缓冲通道（容量10）

// 发送和接收
go func() {
    ch1 <- 42                     // 发送
}()

value := <-ch1                    // 接收

// 关闭通道
close(ch1)

// 检查通道是否关闭
value, ok := <-ch1                // ok=false 表示已关闭

// 遍历通道
for v := range ch1 {
    fmt.Println(v)
}
```

**最佳实践**：
- 发送方负责关闭通道
- 使用 `select` 处理多个通道
- 无缓冲通道用于同步，缓冲通道用于异步

---

#### 4.5.4 指针（Pointer）`*T`

**是什么**：存储变量内存地址的类型。

**有什么用**：
- 共享数据：多个变量指向同一块内存
- 高效传递：避免复制大结构体
- 修改原值：函数内修改外部变量

**特征**：
- 引用语义：通过指针访问的是原数据
- 零值是 `nil`
- 需要解引用（`*ptr`）才能访问值

**使用场景**：
- 大结构体：避免值复制开销
- 需要修改原值：函数参数传递
- 可选值：`*int` 可以表示"有值"或"无值"（nil）

**如何使用**：

```go
// 取地址
x := 42
ptr := &x                         // ptr 是指向 x 的指针

// 解引用
value := *ptr                      // 42

// 通过指针修改
*ptr = 100                         // x 变成 100

// 指针作为函数参数
func increment(p *int) {
    *p++                           // 修改原值
}

increment(&x)                      // x 变成 101

// 结构体指针
type User struct { Name string }
u := &User{Name: "Alice"}          // 直接创建指针
u.Name = "Bob"                     // Go 自动解引用
```

**最佳实践**：
- 小结构体用值传递，大结构体用指针
- 需要修改原值时用指针
- 避免过度使用指针，保持代码简洁

---

## 5. 数组 vs 切片：最典型的对比

这是理解值类型和引用类型的**最佳案例**。

### 5.1 语法区别

```go
arr := [3]int{1, 2, 3}   // 数组：方括号里有数字
slc := []int{1, 2, 3}    // 切片：方括号里没数字
```

### 5.2 行为区别

```go
// 数组（值类型）：复制整个数据
arr1 := [3]int{1, 2, 3}
arr2 := arr1
arr2[0] = 99
// arr1 = [1, 2, 3] ← 没变
// arr2 = [99, 2, 3]

// 切片（引用类型）：共享底层数据
slc1 := []int{1, 2, 3}
slc2 := slc1
slc2[0] = 99
// slc1 = [99, 2, 3] ← 也变了！
// slc2 = [99, 2, 3]
```

### 5.3 为什么需要两种？

**数组的问题**：长度是类型的一部分，`[3]int` 和 `[5]int` 是**不同类型**。

```go
func Sum(arr [3]int) int { ... }

Sum([3]int{1, 2, 3})  // ✅
Sum([5]int{1, 2, 3, 4, 5})  // ❌ 编译错误：类型不匹配
```

**切片的解决方案**：长度不是类型的一部分，可以处理任意长度。

```go
func Sum(arr []int) int { ... }

Sum([]int{1, 2, 3})        // ✅
Sum([]int{1, 2, 3, 4, 5})  // ✅
```

**结论**：实际开发中 **99% 使用切片**，数组只用于极少数底层场景。

### 5.4 切片的内部结构

切片本质是一个小结构体，包含三个字段：

```
切片变量
┌────────────────────┐
│ 指针 → 底层数组     │
│ 长度 (len)         │
│ 容量 (cap)         │
└────────────────────┘
```

赋值 `s2 := s1` 时，复制的是这个结构体（包含指针），所以两个切片指向同一个底层数组。

---

## 6. 结构体的值语义

Go 的结构体是**值类型**，这与 JavaScript 的对象（引用类型）不同。

```go
type User struct { Name string }

u1 := User{Name: "Alice"}
u2 := u1           // 复制了整个结构体
u2.Name = "Bob"
// u1.Name 还是 "Alice"
```

**如果想共享，使用指针**：

```go
u1 := User{Name: "Alice"}
u2 := &u1          // u2 是指针，指向 u1
u2.Name = "Bob"
// u1.Name 变成 "Bob"
```

**这就是 Go 的"控制权"**：
- JavaScript：对象永远是引用，你没得选。
- Go：默认是值（安全），需要共享时用指针（高效）。

---

## 7. 类型转换

Go **不支持隐式转换**，必须显式转换。

```go
var i int = 42
var f float64 = float64(i)   // int → float64

var a int32 = 10
var b int64 = 20
// c := a + b              // ❌ 错误：类型不同
c := int64(a) + b          // ✅ 先转换再运算
```

**字符串转换**：

```go
str := "Hello"
bytes := []byte(str)       // 字符串 → 字节切片
str2 := string(bytes)      // 字节切片 → 字符串
```

---

## 8. 格式化输出

`fmt.Printf` 使用占位符控制输出格式。

### 8.1 常用占位符

| 占位符 | 作用 | 示例 |
| --- | --- | --- |
| `%v` | 默认格式 | `{Alice 25}` |
| `%+v` | 带字段名 | `{Name:Alice Age:25}` |
| `%T` | 类型 | `main.User` |
| `%d` | 十进制整数 | `42` |
| `%s` | 字符串 | `hello` |
| `%f` | 浮点数 | `3.141593` |
| `%.2f` | 2位小数 | `3.14` |
| `%x` | 十六进制 | `2a` |

### 8.2 示例

```go
num := 42
fmt.Printf("十进制: %d\n", num)    // 42
fmt.Printf("十六进制: %x\n", num)  // 2a
fmt.Printf("类型: %T\n", num)      // int

pi := 3.14159
fmt.Printf("两位小数: %.2f\n", pi) // 3.14
```

---

## 9. 自定义类型

### 9.1 类型别名

用 `=` 创建，本质是同一类型：

```go
type MyInt = int    // MyInt 就是 int，可以互换
```

### 9.2 类型定义

不用 `=`，创建全新类型：

```go
type UserID int     // UserID 是新类型
type Age int        // Age 是新类型

var id UserID = 100
var age Age = 25
// age = id         // ❌ 错误：不同类型
age = Age(id)       // ✅ 必须显式转换
```

**用途**：增强类型安全，防止混用（如用户ID和年龄）。

---

## 10. 本章小结

| 概念 | 要点 |
| --- | --- |
| 变量声明 | 函数内用 `:=`，包级别用 `var` |
| 零值 | 声明即初始化，不存在未定义 |
| 值类型 | 赋值复制数据（`int`、数组、结构体） |
| 引用类型 | 赋值共享数据（切片、映射、通道） |
| 数组 vs 切片 | 数组固定长度是值类型；切片动态长度是引用类型 |
| 类型转换 | Go 不支持隐式转换，必须显式 |

**核心记忆**：
1. **切片、映射、通道** → 引用类型（共享）
2. **其他** → 值类型（独立）
3. **想共享结构体** → 用指针 `&`

---

## 11. 动手练习

1. 用 `:=` 和 `var` 分别声明变量，体会区别。
2. 创建一个数组和一个切片，赋值给新变量后修改，观察原变量是否变化。
3. 创建一个结构体，赋值后修改，再用指针赋值后修改，对比结果。
4. 使用 `%T` 打印各种变量的类型。
5. 尝试不转换直接将 `int32` 赋给 `int64`，观察编译器报错。
